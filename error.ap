最短・最大効果で “依存性逆転” をCで実現するための具体的なアクション手順は以下です。


📝 まとめ・やるべきことToDo





	•	まずは “すべての割り当て/解放”をラッパに集約することが最初の一歩！
    対策：「100%」に近づけるための追加アプローチ
	1.	clang-tidyやcppcheckなどの静的解析ツールで「malloc直呼び禁止ルール」を設定
	2.	grepで.hも含めて再検索（ときどき漏れがある）
	3.	CIに「malloc直呼びチェック」のジョブを追加し、“ゼロであること”をテスト化
	4.	定期的に全コードベースでレビュー・自動チェック





✅ 改善提案と実施手順

1. malloc/calloc/realloc/free 直書き検出の自動化
	•	Clang‑Tidy の cppcoreguidelines‑no‑malloc チェックを導入すれば、malloc などの使用を警告し、ラッパー関数利用を強制できます  ￼ ￼。
	•	.clang-tidy に以下を追加：

Checks: "cppcoreguidelines-no-malloc"
WarningsAsErrors: "*"


	•	CI（JenkinsやGitHub Actions）にこのチェックを組み込み、自動でエラーとする。

2. 静的解析ツールのルール追加
	•	cppcheck や clang-tidy（カスタムチェック）で、malloc|free を禁止パターンとして検出する設定を追加。
	•	CIに grep -R -n '\b(malloc|calloc|realloc|free)\b' src/ include/ ジョブを追加し、※検出時はビルド失敗としてアラート。

3. CI 内での禁止ルール検証
	•	Jenkinsなどで、上記 grep / clang-tidy をジョブ化し「禁止パターンゼロ」をマスト条件に。
	•	既存コードには警告だらけでも、一貫した禁止ルールで段階的に修正を促進。

4. 全コードの再検索と検知漏れ補足
	•	.c だけでなく、.h も含めて再検索し、malloc の漏れがないか確認。
	•	grepコマンド例：

grep -R -n --include="*.c" --include="*.h" '\b(malloc|calloc|realloc|free)\b' src/ include/



5. DI 対応 API 拡張設計の導入
	•	malloc/free ラッパー関数（例: ds_malloc, ds_free）がほぼ完了しているとのことですが、次はDS モジュール（例: ds_stack）に「アロケータ構造体受け渡し」を追加する段階です。
	•	API例：

typedef struct { void* (*alloc)(size_t); void (*free)(void*); } ds_allocator_t;

ds_error_t ds_stack_create(const ds_allocator_t* alloc, ds_stack_t **out);


	•	モジュールインスタンスごとに独立したアロケータ指定が可能となるため、テスト環境や移植時に安心して差し替え可能に。

⸻

🎯 なぜこれが必要なのか・メリット・デメリット

メリット	デメリット
✅ 安全性とテスト性向上：malloc直呼びを禁止し、DIを通じてテスト用アロケータの挿入が可能に。	⚠️ 最初の学習コスト：clang-tidy や grep CIジョブ設定、API変更対応に時間がかかる。
✅ 移植性向上：組込み／RT 環境ごとに異なるメモリ管理戦略を、インスタンス単位で注入可能。	⚠️ 設計の複雑化：APIにアロケータ設定を加えるため、呼び出し側に対する影響がある。
✅ 保守性改善：将来 malloc に依存したコードの導入を防ぎ、コードの腐敗を防止。	⚠️ 既存コード修正の工数：大量の置き換えが必要になる可能性あり。
✅ CIによる自動保証：ライブラリ品質担保が自動化され、レビュー負担を軽減。	⚠️ CI依存：ルール追加後に CI が通らなくなる可能性があり、運用負荷が増える。
✅ 拡張性・柔軟性：将来的にメモリプールやトレーシング機構などを差し込める。	⚠️ 一時的スピード低下：初期導入フェーズではリファクタに時間がかかる。


⸻

✔️ 次のステップ
	1.	.clang-tidy に cppcoreguidelines-no-malloc を有効化。
	2.	CIに grep -R malloc ジョブを追加。
	3.	DSモジュールの create API に ds_allocator_t* を受け入れるように変更。
	4.	Jenkinsパイプラインに「静的チェックジョブ」として統合。
	5.	残っている malloc の直書きをリスト化して順次対応。





4. 将来的なDI注入も可能なAPI設計にしていく
	•	余裕が出てきたら
	•	各DS(例: ds_stack_create)で「アロケータ（関数ポインタセット）」を受け取れるようAPIを拡張
	•	それを構造体に持たせ、インスタンスごとに差し替え可能に

例

typedef struct {
  void* (*alloc)(size_t);
  void  (*free)(void*);
} ds_allocator_t;

ds_stack_t* ds_stack_create(const ds_allocator_t* allocator); // allocatorを保持・利用

