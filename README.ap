未来の宅建と英語学習が終わった俺へ伝えたいメッセージ

１　README.apに記載されている内容は、ChatgptにCS,ソフトウェア工学の正しい基準で型を統一して、コードを提出させるために記載している内容なので、
絶対、絶対、絶対消してはダメだよ。

2  All_task.apというファイルにこのディレクトリにおけるcs,ソフトウェア工学に関する学習するべき内容が記載されているため、 All_task.apを学習しながら、
コードを記載すれば、学習はスムーズに元通りに戻せるよ。





　上記をパッチ形式ではなく、上記と下記のを既存のコードを含めて、良い部分を残し、悪い部分を削除して省略せずにガイドラインを厳格に守ってコードを再生成して下さい。　　　
未使用関数の使用しないようにすることも気をつけて。　小規模から大規模までの開発過程を学習したい。そして、PostgresSQL,Flutter,typescript,GCP,docker,kubanetessを将来学習用に採用予定であり、スケーラビリティーが可能な知識を手に入れたい。


🏗️ ソフトウェア工学最前線ガイドライン – 2025-07 完全統合版（先頭に核心ルール配置）

A. コア原則（違反 = CI Fail）　

ID	原則	効果
0-1	アロケータ DI 統一 – 公開 API 第1引数は const ds_allocator_t *alloc 固定	テスト容易・外部依存切替可
0-2	safe calloc/free – alloc(0,sz)→NULL, free(NULL)→no-op	0 byte, NULL クラッシュ防止
0-3	NULL セーフ – NULL 受領時は必ず DS_ERR_NULL_POINTER	NULL-deref 根絶
0-4	命名 & @ownership 統一 – 出力は out_ プレフィクス＋コメントで Ownership 明記	静的解析・人間ミス予防
0-5	破棄は 1 回＋NULL 化	Double-Free/Use-After-Free 防止
0-6	構造体本体は .c – ヘッダにメンバを書かない	ABI 安定・再コンパイル最小化
0-7	ログ 6 段階 (TRACE..FATAL)	運用監視 & デバッグ容易
0-8	テスト main 分離 – すべて tests/test_main.c に集約	CI と単体実行を両立
0-9	Valgrind 0 漏れ – definitely lost = 0	ヒープリーク根絶
0-10	typedef 集約 – 公開型は include/data_structures.h のみ	型定義の迷子を防止


⸻

B. 実践チェックリスト（PR Before-Merge） 

チェック項目	✅ / ❌
公開 typedef は data_structures.h のみに存在する	
公開 API の第1引数が const ds_allocator_t *alloc	
直 malloc/free が 0 行	
構造体本体が .c のみに実装されている	
グローバル変数ゼロ（Mutex/TLS 保護を除く）	
clone() 実装は必要モジュールのみ	
ヘッダに @ownership コメントあり	
テスト関数名が test__<module>_<case>() 形式	
Valgrind definitely lost = 0	
CI（GitHub / Jenkins）で run_ci.sh がパス	

⚠️ どれか 1 つでも × なら即 CI Fail。
特に typedef の場所違反 は最も重い違反です。


0. 目的と適用範囲
	•	再帰的設計・形式手法・セキュリティ・静的解析・教育・運用 を 1 ドキュメントで統一。
	•	すべての品質タスクは run_ci.sh １発 に集約し、
Jenkins・GitHub Actions・GitLab CI など上位ツールは「コンテナで run_ci.sh を実行するだけ」で済む。

⸻

1. 再帰的定義 ― アーキテクチャの核
	•	すべてのデータ構造／VM／GC／Undo-Redo を “自己参照構造体＋再帰関数” で表現。

struct node { int value; struct node *next; };

	•	if-else/switch 地獄を排除し、拡張・テスト・責務分割を容易にする。

⸻

2. 形式言語理論・有限オートマトン

用途	実装指針
入力検証	正規表現 ➜ NFA/DFA
パーサ	LL(k) / LR(k)
Undo/Redo / 履歴	Command パターン＋FSM
スケジューラ	ラウンドロビン FSM


⸻

3. セキュリティ設計 ― アロケータが守る防壁
	•	Double Free : freed_flag で二重解放検出
	•	UAF : Canary と free_table で即時クラッシュ
	•	バウンダリチェック : すべてのバッファ操作が idx >= size を検証
	•	ASLR : mmap + ランダムオフセット
	•	Valgrind : definitely lost = 0 を CI で強制

⸻

4. OS / VM / GC ― 車の両輪

コンポーネント	役割	メモ
仮想メモリ	mmap/sbrk ページ管理	
Allocator	ユーザーヒープ	buddy/slab/TLSF
GC	メモリリーク排除	Mark-Sweep／世代別
VM / JIT	型・バイトコード運用	Arena alloc で高速


⸻

5. 静的解析・形式検証・Fuzzing
	•	clang-tidy --warnings-as-errors=*
	•	cppcheck --error-exitcode=1
	•	CBMC / Frama-C で契約 (requires / ensures) を自動証明
	•	libFuzzer / AFL++ を run_ci.sh で自動実行

⸻


7. クロスプラットフォーム原則
	•	make build && make test は Mac / Windows(WSL) / Linux / Docker で完全同一。
	•	make docker-arm64 / make docker-amd64 / make docker-all でクロスビルド検証。
	•	依存パッケージは scripts/ci_env_setup.sh が OS 判定して自動導入。

⸻

8. CI/CD 統合 ― run_ci.sh 採用

8-1 run_ci.sh 主要タスク

#!/usr/bin/env bash
set -euo pipefail
scripts/lint.sh          # clang-format / eslint …
scripts/static_analysis.sh
scripts/build.sh         # Makefile 経由
scripts/test.sh          # 単体 + 統合
scripts/coverage.sh      # gcov→HTML
scripts/fuzz.sh          # libFuzzer / AFL++
valgrind --leak-check=full build/bin/main

8-2 Jenkinsfile（抜粋）

pipeline {
  agent { docker { image 'docker:24.0-cli' args '--privileged' } }
  stages {
    stage('CI') {
      steps {
        sh 'chmod +x ./run_ci.sh && ./run_ci.sh'
      }
    }
  }
  post {
    always {
      archiveArtifacts artifacts: 'build/**'
      junit 'build/test/*.xml'
    }
  }
}

8-3 GitHub Actions .github/workflows/ci.yml

name: CI (multi-arch)
on: [push, pull_request]
jobs:
  build-test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        platform: [linux/amd64, linux/arm64]
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-qemu-action@v3
      - uses: docker/setup-buildx-action@v3
      - run: chmod +x ./run_ci.sh && ./run_ci.sh


⸻

9. Docker (multi-arch, GLIBC 統一)

##################### 🔨 Build Stage #####################
FROM gcc:12-bookworm AS builder        # GLIBC 2.38
WORKDIR /app
COPY . .
RUN rm -rf build/ docs/ coverage/ && \
    chmod +x ./scripts/*.sh ./run_ci.sh || true && \
    ./scripts/build.sh && \
    test -f build/bin/main && chmod +x build/bin/main

##################### 🚀 Production Stage ################
FROM debian:bookworm-slim
WORKDIR /app
COPY --from=builder /app/build/bin /app/bin
ENTRYPOINT ["/app/bin/main"]

	•	docker buildx build --platform linux/{amd64,arm64} -t yourapp . --load で両アーキテクチャ成功済み。



11. 参考実装スニペット（契約プログラミング & Doxygen）

/**
 * @brief  スタック生成
 * @pre    alloc != NULL
 * @pre    out_stack != NULL
 * @post   *out_stack != NULL
 * @ownership caller frees via ds_stack_destroy()
 */
ds_error_t
ds_stack_create(const ds_allocator_t *alloc,
                ds_stack_t          **out_stack)
{
    assert(alloc && out_stack);

    ds_stack_t *s = ds_malloc(alloc, 1, sizeof *s);
    if (!s) return DS_ERR_ALLOC;

    s->alloc = alloc;
    s->size  = 0;
    s->cap   = 16;
    s->data  = ds_malloc(alloc, s->cap, sizeof(void *));
    if (!s->data) { ds_free(alloc, s); return DS_ERR_ALLOC; }

    *out_stack = s;
    return DS_SUCCESS;
}

上記コメントはそのまま Doxygen で API ドキュメント化される。
