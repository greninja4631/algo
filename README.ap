<<<<<<< HEAD
<<<<<<< HEAD
/**
 * @file    tests/util/test_metrics.c
 * @brief   util/metrics モジュールのユニットテスト
 * @note    main() は tests/test_main.c に集約される
 */

#include "util/test_metrics.h"   /* void test__metrics_basic(void); */
#include "util/metrics.h"        /* 被テスト API */
#include "util/logger.h"         /* ds_log() & DS_LOG_LEVEL_*      */

/* グローバル DI アロケータ（必要なら）  */
extern const ds_allocator_t *g_alloc;

/* ───────────────────────────── */
/* 共通アサート・マクロ            */
#define DS_TEST_ASSERT(cond, msg)                                           \
    do {                                                                    \
        if (cond) { ds_log(DS_LOG_LEVEL_INFO,  "[PASS] %s", (msg)); }       \
        else      { ds_log(DS_LOG_LEVEL_ERROR, "[FAIL] %s (%s:%d)",         \
                           (msg), __FILE__, __LINE__); }                    \
    } while (0)

/* ───────────────────────────── */
/* 基本動作テスト                  */
void test__metrics_basic(void)
{
    /* 1. 全リセット (@side-effect: global) */
    ds_metrics_reset_all(g_alloc);
=======
　上記をパッチ形式ではなく、📚 Cプロジェクト API設計・実装 完全統一ガイドライン
上記と下記のを既存のコードを含めて、良い部分を残し、悪い部分を削除して省略せずにガイドラインを厳格に守ってコードを再生成して下さい。　　　
=======
　上記をパッチ形式ではなく、上記と下記のを既存のコードを含めて、良い部分を残し、悪い部分を削除して省略せずにガイドラインを厳格に守ってコードを再生成して下さい。　　　
>>>>>>> feature



はい、あなたの全要件と「再帰的定義」「形式言語理論」「セキュアアロケータ」「OS/VM/GC連携」「静的解析・形式手法」等の全ての知見を一元統合した完全版ガイドラインを、良い部分だけを残しつつ一切省略なしで加筆修正版として提示します。

⸻

🏗️【ソフトウェア工学最前線ガイドライン 完全強化版（2025-07・統合版）】

⸻

0. 目的と適用範囲
	•	src/, include/, tests/ 以下に置かれる全Cソース・ヘッダ・テスト・CI/CDスクリプトを完全に包含。
	•	Dockerコンテナ内で走る全ビルド＆CI（run_ci.sh, Jenkinsfile, GitHub Actions）を標準化。
	•	「再帰的設計」「形式手法」「セキュリティ」「静的解析」「教育」「現場運用」まで全層的品質保証を担保。

⸻

1. 🧩「再帰的定義」：アーキテクチャの本質

全ての抽象データ構造・VM・GC・アロケータ・Undo/Redoは「再帰的定義」で構築することが必須条件。
	•	リスト（自己参照構造体）

struct node { T value; struct node* next; };

<<<<<<< HEAD
<<<<<<< HEAD
#	原則	要旨
0-1	アロケータ DI 統一	すべての公開 API の第 1 引数はconst ds_allocator_t *alloc固定。alloc==NULL時は ds_malloc/ds_freeへ自動フォールバック。
0-2	calloc/free 安全設計	_std_allocは「cnt==0→NULL」、_std_freeは「p==NULL→no-op」。本番/テストいずれも free(NULL) が必ず安全。
0-3	NULL セーフ API	あらゆる API は NULL を⾮致命的エラーとして扱い DS_ERR_NULL_POINTER を返す – CI で NULL deref が無いことを保証。
0-4	命名・out_・@ownership 統一	命名ルールは §1、出力引数は 必ず out_ プレフィクス、メモリ所有権は Doxygen @ownership を 100 % 明示。
0-5	破棄は 1 回だけ	どのリソースも 二重 free 禁止。destroy/reset/clear など破棄系列 API は free 済ポインタを NULL へセットし再利用不可にする。
0-6	構造体本体は .c	DTO 例外を除き 構造体本体は .c ファイル 1 か所のみ。ヘッダでメンバ公開禁止。
0-7	ログ 6 段 + アサーション	ログは TRACE/DEBUG/INFO/WARN/ERROR/FATAL の 6 段、アサートは DS_TEST_ASSERT / TASSERT 統一。
0-8	テスト main() 分離	各テストはスタンドアロン実行可能だが、実際の CI ランは tests/test_main.c が一括呼び出し。
0-9	Valgrind & 拡張容易性	すべてのモジュールは Valgrind “definitely lost” = 0 を CI で保証し、後方互換を壊さず拡張できる設計にする。
>>>>>>> feature
=======
⸻
=======
>>>>>>> feature

	•	ツリー・AST（抽象構文木）
子ノードを再帰的にたどり、JIT/VMでも各ノードを再帰的にinterpret/compile
	•	コマンド履歴（Undo/Redo）
Commandオブジェクトのapply/undoを再帰的連鎖で履歴管理
	•	ヒープ管理（Buddy Allocatorなど）
メモリを2^n単位で再帰分割/統合することでヒープ効率とセキュリティを両立
	•	GC（Mark & Sweep等）
オブジェクトグラフを再帰的に走査、到達不能メモリを自動開放

<<<<<<< HEAD
ID	原則名	具体ルール（曖昧さゼロで記述）	理由 / 効果
0-1	アロケータ DI 統一	公開 API の 第 1 引数は const ds_allocator_t *alloc に固定。 alloc == NULL の場合は ds_malloc/ds_free/ds_realloc が暗黙フォールバック。	・テスト時にモックアロケータを注入できる。・メモリ出口を 1 か所に集約できる。
0-2	calloc/free 安全設計	_std_alloc(cnt,sz) は cnt == 0 で NULL を返す。_std_free(p) は p == NULL で no-op。	“ゼロバイト確保”や “free(NULL)” でクラッシュしない。
0-3	NULL セーフ API	どの API も NULL を致命的クラッシュにしない。必ず DS_ERR_NULL_POINTER を返す。	NULL-deref を CI でゼロに保つ。
0-4	命名・@ownership 統一	出力ポインタはすべて out_ プレフィクス。Doxygen の @ownership は caller frees / callee frees / transfer の 3 択を必ず付ける。	人間・静的解析ツールが所有権を誤解しない。
0-5	破棄は 1 回だけ	destroy/reset 系 API は、内部で free 後 ポインタを NULL へ。二重 free が起きても no-op。	二重 free バグ完全防止。
0-6	構造体本体は .c	DTO を除き、メンバ宣言は .c ファイル 1 箇所のみ。ヘッダは forward-decl のみ。	ABI 変更がヘッダに波及しない。
0-7	ログ 6 段	`ds_log(TRACE	DEBUG
0-8	テスト main 分離	個別 test ファイルは #ifdef DS_STANDALONE_TEST 時のみ main() を持つ。CI では tests/test_main.c が全テストを集約。	単体実行と CI 実行の両立。
0-9	Valgrind 0 漏れ	CI の valgrind --leak-check=full で “definitely lost” = 0 を強制。	リークを早期に潰す。
>>>>>>> feature
=======
補足：
再帰設計を無視したAPIはif-else/switch肥大地獄・スパゲティ設計となり、現場で即座に技術負債となる。
再帰性＝拡張性・テスト容易性・責務分割の核。CSの基礎理論の実践的価値。

⸻

2. 🧮「形式言語理論・有限オートマトン」：実装の安全・予測性
	•	FSM設計はパーサ・VM・Undo/Redo・スケジューラ全ての信頼性保証の根幹
	•	正規表現→有限オートマトン化で入力検証、LL(k)/LR(k)パーサで構文解釈
	•	Undo/Redo/履歴管理はFSMとして設計：State/Command/Invariantsで安全担保
	•	ラウンドロビンスケジューラや多段階状態機械にも応用

current_state = (prev + quantum) % n;



補足：
FSM的な抽象がなければ「バグ地獄・分岐地獄・テスト地獄」。
FSM設計こそ現場エンジニアの基本教養。

⸻

3. 🔐 セキュリティ設計：「アロケータ」が守る防壁
	•	Double Free防御：free時にfreed_flag/ヒープ監視テーブルを実装。2重freeでクラッシュ/不整合回避
	•	UAF (Use After Free)防御：Canaryやfree_tableにより開放済みアクセスを即検知
	•	バウンダリチェック：すべてのバッファ操作は境界検証if (idx >= size)を明示・CIでも検査
	•	ASLR対応：アロケーション位置ランダム化（OSのASLR機構も併用）
	•	Valgrind対応：全てのds_malloc/ds_freeのトレースログを出力・ヒープリークゼロを保証

補足：
ds_allocator/ヒープ管理はLinuxカーネルやglibc技術の集大成。自作できれば「OS・IoT・SaaS」全分野に直結。

⸻

4. 🎯「OS/VM/GC」：一体設計・車の両輪

構成要素	担当領域	備考
OS (Virtual Memory)	ページ管理/保護	mmap/sbrkでカスタムアロケータ設計
Allocator	ユーザーヒープ管理	malloc/buddy/slab/TLSF設計戦略
GC	メモリリーク/循環参照除去	Mark & Sweep/Generational/Arena方式
VM/LLVM/WASM	型・バイトコード・スタック	GC有無でABI・最適化が根本的に変わる

	•	arena_allocator/bump_allocatorの実装でWASM/JIT/LLVMへの移植性大幅UP
	•	VM設計・GC設計とアロケータは「設計・最適化・安全性」の両輪

⸻

5. 🧪「静的解析・形式検証・Fuzzing」：CI/CDと一体化した高品質保証
	•	clang-tidy/cppcheck：構文/論理/メモリエラーの事前発見を自動化
	•	CBMC / Frama-C：関数ごとの契約（requires/ensures/invariant）を形式的に証明
例:

/*@ requires 0 <= index < size;
    ensures \result == array[index];
*/
int get_element(int *array, int size, int index);


	•	libFuzzer/AFL++：クラッシュ/未定義動作を自動探索→必ずCI/CDに組み込む

補足：
CI/CDでrun_ci.shから「valgrind definitely lost=0」「静的解析・形式検証・Fuzzing全自動」を実現せよ。

⸻



7. コア原則（違反はビルド/CI即Fail）

ID	原則名	具体ルール	効果
0-1	アロケータDI統一	公開APIの第1引数はconst ds_allocator_t* alloc固定	テスト性/モック化/品質保証
0-2	calloc/free安全設計	_std_alloc(0,sz)はNULL、_std_free(NULL)はno-op	ゼロバイト/NULLクラッシュ防止
0-3	NULLセーフAPI	NULL引数は必ずDS_ERR_NULL_POINTER	NULL-deref完全排除
0-4	命名・@ownership統一	出力はout_プレフィクス、@ownership明記	静的解析/人間ミス予防
0-5	破棄は1回だけ	destroy/reset後はNULL化	二重free完全防止
0-6	構造体本体は.c	DTO以外はヘッダにメンバ禁止	ABI変更の影響極小化
0-7	ログ6段階	ds_log(TRACE..FATAL)	運用監視/トレーサビリティ
0-8	テストmain分離	tests/test_main.cに集約	CIと単体実行の両立
0-9	Valgrind 0漏れ	definitely lost=0必須	ヒープリーク根絶
>>>>>>> feature

    /* 2. カウンタ加算 */
    ds_metrics_increment(g_alloc, "test.counter");
    ds_metrics_increment(g_alloc, "test.counter");
    int64_t v = ds_metrics_get(g_alloc, "test.counter");
    DS_TEST_ASSERT(v == 2, "test.counter == 2");

    /* 3. 別カウンタ */
    ds_metrics_increment(g_alloc, "other");
    DS_TEST_ASSERT(ds_metrics_get(g_alloc, "other") == 1, "other == 1");

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
    /* 4. 合計チェック（get_total API が無い場合は個別集計） */
    int64_t total =
        ds_metrics_get(g_alloc, "test.counter") +
        ds_metrics_get(g_alloc, "other");
    DS_TEST_ASSERT(total == 3, "total == 3");

    ds_log(DS_LOG_LEVEL_INFO, "[OK] test__metrics_basic 完了");
}
=======
1. 命名規約 & 型設計ルール（超詳細版）
=======
2. 命名規約・型設計（IDE 補完 & リファクタに強い）
	1.	構造体本体
>>>>>>> feature

// src/ds/stack.c のみ
struct ds_stack { … };


	2.	前方宣言 typedef

/* include/data_structures.h */
typedef struct ds_stack ds_stack_t;

すべての typedef を 1 ファイルに集中させることで多重定義を排除。

	3.	関数命名 ds_stack_create() / ds_stack_push() … 動詞必須
	4.	エラーコード DS_ERR_STACK_OVERFLOW
	5.	getter/setter ds_stack_get_size() / ds_stack_set_limit()
	6.	clone ds_stack_clone(const ds_stack_t *src) は必ず深いコピー
=======
8. 拡張ロードマップ（教育・運用・OSSレベル拡張）
	•	LLVM/JIT/仮想メモリとの連携
	•	buddy/slab allocator設計・GC拡張・LLVM最適化連携・JIT生成コード領域の安全管理
	•	セキュリティ最前線
	•	double free/UAF/poisoning/Fortify Source/stack canary/ASLR/fault injection全ての自動検証
	•	メモリ可視化・ヒープトレース
	•	ds_malloc_traceモード/heapマップ/JSONログ/ELK連携
	•	教育・カリキュラム統合
	•	ヒープ可視化/undo-redo有限オートマトン図示/ABI図解/pointer ownershipのSVG出力
	•	形式手法・静的解析
	•	Frama-C/CBMCによる証明/MISRA-C/カバレッジ/fuzzingによる死角ゼロ設計
>>>>>>> feature

⸻

9. 参考API実装（契約プログラミング&Doxygen）

/**
 * @brief    スタック生成
 * @pre      alloc != NULL
 * @pre      out_stack != NULL
 * @post     *out_stack != NULL
 * @ownership caller frees (ds_stack_destroy)
 */
ds_error_t ds_stack_create(const ds_allocator_t *alloc,
                           ds_stack_t          **out_stack)
{
    assert(alloc && out_stack);
    ds_stack_t *s = ds_malloc(alloc, 1, sizeof *s);
    if (!s) return DS_ERR_ALLOC;
    s->alloc = alloc;
    s->size  = 0;
    s->cap   = 16;
    s->data  = ds_malloc(alloc, s->cap, sizeof(void*));
    if (!s->data) { ds_free(alloc, s); return DS_ERR_ALLOC; }
    *out_stack = s;
    return DS_SUCCESS;
}


⸻

10. CI/CD統合とrun_ci.sh（最重要）
	•	Jenkins/GitHub Actions/GitLab等、run_ci.sh一発で全品質管理
	•	禁止API grep、clang-tidy/cppcheck/valgrind/Fuzzingを完全自動化
	•	どのCIサービスでも全く同じ品質条件で管理（YAML/Groovyでrun_ci.shを呼ぶだけ）

8. 既存コード移行チェックリスト（PR Before-Merge）

チェック項目	Yes / No
typedef が data_structures.h に集約されている	
公開 API が alloc を第 1 引数に持つ	
直 malloc/free が 0 行 (grep 済)	
構造体本体が .c のみ	
グローバル変数ゼロ (例外は Mutex/TLS 保護)	
clone() 実装（必要モジュールのみ）	
ヘッダで @ownership 明記済み	
テスト名 test__<module>_<case>() 形式	
Valgrind “definitely lost” = 0	


⸻

9. アンチパターン（検出＝即 Fail）
	•	構造体本体をヘッダに書いて再定義
	•	テストのためにプリプロセッサで本番ヘッダを切り替える
	•	本番コードに printf/puts/perror 系
<<<<<<< HEAD
	•	goto fail; スパゲティ

⸻

<<<<<<< HEAD
11. 絶対 NG アンチパターン
	•	型多重定義 / 構造体本体のヘッダ重複
	•	テストのためにプリプロセッサで本番ヘッダを切替
	•	本番コードで printf / perror / fprintf(stderr, …)
	•	スパゲティな goto fail; 多用
>>>>>>> feature
=======
10. 拡張ロードマップ（優先順位つきタスク）
	1.	ヘルパ / stack.c など残る直 malloc を grep → 修正
	2.	全 API に契約プログラミング導入 (@pre/@post)
	3.	ジェネリック DS (_Generic + copy/compare)
	4.	スレッド安全版 DS（mutex / lock-free）
	5.	メモリプール API (ds_pool_alloc) + ベンチマーク
	6.	ds_error_t にメッセージテーブル + ds_strerror()
	7.	構造化ログ JSON → ELK 連携
	8.	Jenkins CI/CD 完全自動化
	9.	gcovr カバレッジ 80%↑, Fuzzing, MISRA-C 静的解析
	10.	形式手法 (Frama-C / CBMC) Nightly 実行

各タスク完了時点で ガイドラインを都度更新し、CI にチェックを追加する。

⸻

11. 参考実装スニペット
=======
	•	goto fail; スパゲティ　　　　11. 参考実装スニペット
>>>>>>> feature

11-1. スタック生成 API 完全版

/**
 * @brief    スタック生成
 * @pre      alloc != NULL
 * @pre      out_stack != NULL
 * @post     *out_stack != NULL
 * @ownership caller frees (ds_stack_destroy)
 */
ds_error_t ds_stack_create(const ds_allocator_t *alloc,
                           ds_stack_t          **out_stack)
{
    assert(alloc && out_stack);

    ds_stack_t *s = ds_malloc(alloc, 1, sizeof *s);
    if (!s) return DS_ERR_ALLOC;

    s->alloc = alloc;
    s->size  = 0;
    s->cap   = 16;
    s->data  = ds_malloc(alloc, s->cap, sizeof(void*));
    if (!s->data) { ds_free(alloc, s); return DS_ERR_ALLOC; }

    *out_stack = s;
    return DS_SUCCESS;
}


⸻
11-2. CI/CD 実行方法（run_ci.sh 採用）

● 原則  
  Jenkins／GitHub Actions／GitLab CI 等の上位ツールは  
  「Docker コンテナ内で run_ci.sh を 1 行実行する」だけでよい。

● 手順  
  - Jenkinsfile 例
      pipeline {
        agent any
        stages {
          stage('CI') {
            steps {
              sh 'chmod +x ./run_ci.sh && ./run_ci.sh'
            }
          }
        }
      }

  - GitHub Actions 例 (.github/workflows/ci.yml)
      jobs:
        build:
          runs-on: ubuntu-latest
          steps:
            - uses: actions/checkout@v4
            - run: chmod +x ./run_ci.sh && ./run_ci.sh
<<<<<<< HEAD

● run_ci.sh の責務  
  1) make clean / make build  
  2) clang-tidy ＋ cppcheck（警告→エラー）  
  3) 禁止 API grep（malloc/calloc/realloc/free 直呼びゼロ）  
  4) ユニットテスト実行  
  5) Valgrind --leak-check=full (definitely lost = 0)  
  6) 生成物一覧／Doxygen／カバレッジ (任意)  
  7) エラー発生時は非ゼロ終了で CI Fail

● 重要ポイント  
  - CI ツール固有の YAML／Groovy は “run_ci.sh を呼ぶだけ” に抑え、  
    すべての品質チェックを **run_ci.sh 側**で一元管理する。  
  - これにより複数 CI プラットフォーム間で品質条件がずれない。
<<<<<<< HEAD
>>>>>>> feature
=======


  はい、あなたが提示された内容はすでに極めて完成度が高く、実際に世界水準のソフトウェア工学・Cアーキテクチャ設計・CSカリキュラムの基礎として十分に機能します。

ただし、**“完璧”**とするために、以下の観点を最終補強として追加することを強く推奨します：

⸻

✅【最終補強】追加すべき観点（2025-07 完全改訂・補強版）

⸻

12. LLVM・JIT・仮想メモリ・OSカーネル設計との連携視点

項目	補足内容
Buddy Allocator の導入	OSカーネル・glibcレベルで採用。任意ブロックサイズの2の冪アロケーション対応。
Slab Allocator の参考設計	オブジェクトのキャッシュ再利用によるパフォーマンス向上（例：ds_stack_pool）
LLVM IR での malloc 表現	llvm.memcpy・llvm.malloc 系との接続視点。最適化パスでのメモリ生存期間の推論にも関与。
GC設計の土台	mark-and-sweep／reference counting での所有権設計のベースとして allocator API 拡張が必要。
仮想メモリレイアウト理解	.text / .data / .bss / heap / stack のアドレス空間上の関係とmallocのヒープ境界設計（brk/sbrk）
実行時メモリ圧縮の設計視点	例：jemallocのmadvise、Transparent Huge Pages（THP）との連携知識
JIT向けアロケーション制御	JITが生成するコード領域の実行許可（executable heap）セクションのセキュリティ含む制御必要性。


⸻

13. セキュリティ設計の最前線視点

項目	詳細
Double Free・UAF 検知	free() 後に NULL 化する防御がデフォルト。さらに ds_free_secure() により監視強化可能。
Poisoning テクニック	ヒープ解放後の領域にパターン（例：0xDEADBEEF）を書き込むことで UAF 検知。
Fortify Source の活用	-D_FORTIFY_SOURCE=2 による境界検知付き関数への自動置換。
Stack Canary 導入	-fstack-protector-strong によるスタックバッファ破壊の検知。
Hardened malloc 概念導入	glibc, musl 等で採用される「metadata分離」「ヒープレイアウトランダマイズ」視点導入。
ASLR (Address Space Layout Randomization)	malloc / mmap 領域のランダマイズ耐性設計。
Allocator Fault Injection	テスト時に意図的に malloc 失敗を注入 → 各APIの fail-safe をバグ耐性 CI で検証。


⸻

14. メモリ可視化とトレースログ強化

機能	実装内容例
ds_malloc_trace モード	アドレス・サイズ・呼び出し元（__FILE__, __LINE__）ログを標準出力 or ファイル出力。
JSONログ出力の切り替え	ds_set_log_format(JSON) でログ形式変更、ELK連携可能。
メモリヒープマップ出力	ds_dump_heap_map() により全体構造を図形式出力。
malloc統計（累積/現在）	総malloc回数、失敗回数、合計バイト数、最大バーストなど。


⸻

15. 教育理論・カリキュラム統合（学習者・後進育成対応）

項目	内容
可視化重視のメモリアロケータ	mallocのヒープ領域を色分け図でリアルタイム可視化（教育向けビルド）
undo/redo を有限オートマトンで図示	状態遷移（push/pop）を DFA 状態遷移表・図で表現
構造体の ABI・alignment を図で解説	offsetof, alignof, padding をビット単位図解
pointer ownership を色付き線で解説	call graph + 所有関係（ownership map）を SVG で出力


⸻

16. 形式手法・証明・静的解析までの最終展開

技法	解説
Frama-C の導入	Hoare論理ベースで C のポインタ安全性／ヒープ破壊チェック可能
CBMC のモデル検査	状態遷移（undo/redo, スタック溢れ）に対し全探索での死活検証
MISRA-C 対応	医療・自動車業界の静的コードルール。ルール適合を cppcheck で自動化
fuzzing 対応	AFL++ による heap overflow / use-after-free など未定義動作の発見

>>>>>>> feature
=======
>>>>>>> feature
